// Scene Generator for Pygame Components
// Combines selected components into a complete pygame game script

import { ComponentSelection, PygameComponent } from './pygame-components/types';
import { getComponentById } from './pygame-components';

export interface SceneConfig {
  name: string;
  width: number;
  height: number;
  fps: number;
  backgroundColor: string;
}

export interface GeneratorOptions {
  sceneConfig: SceneConfig;
  selectedComponents: ComponentSelection[];
  assetMapping?: Record<string, string>;
}

// Template parameter replacer
function replaceTemplateParams(code: string, params: Record<string, any>, assets: Record<string, string> = {}): string {
  let result = code;
  
  // Replace parameters
  Object.entries(params).forEach(([key, value]) => {
    const regex = new RegExp(`\{\{${key}\}\}`, 'g');
    result = result.replace(regex, String(value));
  });
  
  // Replace asset references
  Object.entries(assets).forEach(([key, path]) => {
    const regex = new RegExp(`\{\{${key}\}\}`, 'g');
    result = result.replace(regex, `"${path}"`);
  });
  
  return result;
}

// Main scene generator function
export function generatePygameScene(options: GeneratorOptions): string {
  const { sceneConfig, selectedComponents } = options;
  
  // Group components by type for organized code generation
  const componentSystems: Record<string, string[]> = {
    movement: [],
    combat: [],
    ui: [],
    world: []
  };
  
  // Process each selected component
  selectedComponents.forEach(selection => {
    const component = getComponentById(selection.componentId);
    if (!component) return;
    
    // Get the selected variant code
    const variantCode = component.variants[selection.variant].pythonCode;
    
    // Merge parameters and assets with selection overrides
    const mergedParams = { ...component.parameters, ...selection.parameters };
    const mergedAssets = { ...selection.assets };
    
    // Replace template parameters and assets
    const processedCode = replaceTemplateParams(
      variantCode,
      mergedParams,
      mergedAssets
    );
    
    componentSystems[component.category].push(processedCode);
  });
  
  // Generate the complete pygame script
  return `#!/usr/bin/env python3
"""
${sceneConfig.name}
Generated by Pygame Component System
"""

import pygame
import sys
import math
import random
import json
import time

# Initialize Pygame
pygame.init()
pygame.mixer.init()
pygame.font.init()

# Game Configuration
SCREEN_WIDTH = ${sceneConfig.width}
SCREEN_HEIGHT = ${sceneConfig.height}
FPS = ${sceneConfig.fps}
BACKGROUND_COLOR = pygame.Color("${sceneConfig.backgroundColor}")

# Create game window
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("${sceneConfig.name}")
clock = pygame.time.Clock()

# Player class with all required attributes
class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.width = 40
        self.height = 40
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        self.facing_right = True
        self.rect = pygame.Rect(x, y, self.width, self.height)
        self.health = 100
        self.max_health = 100
        self.mass = 1.0
        self.elasticity = 0.8
        
    def update(self):
        self.rect.x = int(self.x)
        self.rect.y = int(self.y)
        
    def draw(self, screen):
        color = (0, 100, 255)
        pygame.draw.rect(screen, color, self.rect)
        # Draw facing direction indicator
        if self.facing_right:
            pygame.draw.rect(screen, (255, 255, 255), 
                           (int(self.x + self.width - 10), int(self.y + 10), 5, 20))
        else:
            pygame.draw.rect(screen, (255, 255, 255),
                           (int(self.x + 5), int(self.y + 10), 5, 20))
    
    def play_sound(self, sound_path):
        # Placeholder for sound playing
        # In real implementation, would load and play the sound
        pass
        
    def take_damage(self, amount):
        self.health = max(0, self.health - amount)
        return self.health > 0

# Enemy base class
class Enemy:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.width = 30
        self.height = 30
        self.velocity_x = 0
        self.velocity_y = 0
        self.rect = pygame.Rect(x, y, self.width, self.height)
        self.health = 50
        self.mass = 0.8
        self.elasticity = 0.5
        
    def take_damage(self, amount):
        self.health -= amount
        
    def stun(self, duration):
        # Placeholder for stun effect
        pass
        
    def update(self):
        self.rect.x = int(self.x)
        self.rect.y = int(self.y)
        
    def draw(self, screen):
        color = (200, 50, 50)
        pygame.draw.rect(screen, color, self.rect)

# Platform class
class Platform:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.rect = pygame.Rect(x, y, width, height)
        
    def draw(self, screen):
        pygame.draw.rect(screen, (100, 100, 100), self.rect)

# Initialize game objects
player = Player(100, 300)
enemies = []
platforms = [
    Platform(0, 550, 800, 50),  # Ground
    Platform(200, 450, 150, 20),  # Platform 1
    Platform(450, 350, 150, 20),  # Platform 2
    Platform(300, 250, 100, 20),  # Platform 3
]

# Component Systems
${componentSystems.movement.length > 0 ? '# Movement Systems\n' + componentSystems.movement.join('\n') : ''}
${componentSystems.combat.length > 0 ? '\n# Combat Systems\n' + componentSystems.combat.join('\n') : ''}
${componentSystems.ui.length > 0 ? '\n# UI Systems\n' + componentSystems.ui.join('\n') : ''}
${componentSystems.world.length > 0 ? '\n# World Systems\n' + componentSystems.world.join('\n') : ''}

# Initialize component systems
${selectedComponents.map(sel => {
  const component = getComponentById(sel.componentId);
  if (!component) return '';
  
  // Generate initialization code based on component type
  switch(component.id) {
    case 'jump':
      return 'jump_system = JumpSystem(player)';
    case 'walk':
      return 'walk_system = WalkSystem(player)';
    case 'shooting':
      return 'shooting_system = ShootingSystem(player)';
    case 'melee':
      return 'melee_system = MeleeSystem(player)';
    case 'health':
      return 'health_system = HealthSystem(player)';
    case 'score':
      return 'score_system = ScoreSystem()';
    case 'gravity':
      return 'gravity_system = GravitySystem()\ngravity_system.add_entity(player)';
    case 'collision':
      // Check variant to use correct method name
      if (sel.variant === 'B') {
        return 'collision_system = CollisionSystem()\nfor platform in platforms:\n    collision_system.add_static_object(platform)';
      } else {
        return 'collision_system = CollisionSystem()\nfor platform in platforms:\n    collision_system.add_solid(platform)';
      }
    default:
      return '';
  }
}).filter(line => line).join('\n')}

# Main game loop
running = True
dt = 0

while running:
    # Calculate delta time
    dt = clock.tick(FPS) / 1000.0
    
    # Handle events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
    
    # Get input states
    keys = pygame.key.get_pressed()
    mouse_pos = pygame.mouse.get_pos()
    
    # Update systems
${selectedComponents.map(sel => {
  const component = getComponentById(sel.componentId);
  if (!component) return '';
  
  // Generate update code based on component type
  switch(component.id) {
    case 'jump':
      return '    jump_system.update(keys, dt)';
    case 'walk':
      return '    walk_system.update(keys, dt)';
    case 'shooting':
      return '    shooting_system.update(keys, mouse_pos, dt)';
    case 'melee':
      return '    melee_system.update(keys, enemies, dt)';
    case 'health':
      return '    health_system.update(dt)';
    case 'score':
      return '    score_system.update(dt)\n    score_system.collect_item(player.rect)';
    case 'gravity':
      return '    gravity_system.update(dt, platforms)';
    case 'collision':
      return '    collision_system.update()';
    default:
      return '';
  }
}).filter(line => line).join('\n')}
    
    # Update player position
    if hasattr(player, 'velocity_x'):
        player.x += player.velocity_x * dt
    if hasattr(player, 'velocity_y'):
        player.y += player.velocity_y * dt
    player.update()
    
    # Update enemies
    for enemy in enemies:
        enemy.update()
    
    # Clear screen
    screen.fill(BACKGROUND_COLOR)
    
    # Draw platforms
    for platform in platforms:
        platform.draw(screen)
    
    # Draw player
    player.draw(screen)
    
    # Draw enemies
    for enemy in enemies:
        enemy.draw(screen)
    
    # Draw component visuals
${selectedComponents.map(sel => {
  const component = getComponentById(sel.componentId);
  if (!component) return '';
  
  // Generate draw code for components with visual elements
  switch(component.id) {
    case 'shooting':
      return '    shooting_system.draw(screen)';
    case 'melee':
      return '    melee_system.draw(screen)';
    case 'health':
      return '    health_system.draw(screen)';
    case 'score':
      return '    score_system.draw(screen)';
    default:
      return '';
  }
}).filter(line => line).join('\n')}
    
    # Update display
    pygame.display.flip()

# Cleanup
pygame.quit()
sys.exit()`;
}

// Helper function to generate a minimal test scene
export function generateTestScene(): string {
  const testConfig: GeneratorOptions = {
    sceneConfig: {
      name: 'Component Test Scene',
      width: 800,
      height: 600,
      fps: 60,
      backgroundColor: '#1a1a2e'
    },
    selectedComponents: [
      {
        componentId: 'walk',
        variant: 'A',
        assets: {},
        parameters: { max_speed: 200 }
      },
      {
        componentId: 'jump',
        variant: 'A',
        assets: {},
        parameters: { jump_power: 15 }
      },
      {
        componentId: 'gravity',
        variant: 'A',
        assets: {},
        parameters: {}
      },
      {
        componentId: 'collision',
        variant: 'A',
        assets: {},
        parameters: {}
      },
      {
        componentId: 'health',
        variant: 'A',
        assets: {},
        parameters: { max_health: 100 }
      },
      {
        componentId: 'score',
        variant: 'A',
        assets: {},
        parameters: {}
      }
    ]
  };
  
  return generatePygameScene(testConfig);
}