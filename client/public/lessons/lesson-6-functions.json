{
  "nodes": {
    "start": {
      "id": "start",
      "speaker": "Pixel",
      "text": "Level 6 - FUNCTIONS! Time to create your own commands! ðŸŽ¯",
      "followUp": "Functions are like creating your own power-ups - write once, use anywhere!",
      "options": [
        {
          "text": "Show me function power!",
          "next": "firstFunction"
        },
        {
          "text": "Why do I need functions?",
          "next": "whyFunctions"
        }
      ]
    },
    "whyFunctions": {
      "id": "whyFunctions",
      "speaker": "Pixel",
      "text": "Imagine coding 'enemy takes damage' 50 times... NO! Write it once as a function, call it 50 times!",
      "followUp": "Functions = no repeating yourself = happy programmer = better games!",
      "options": [
        {
          "text": "Sold! Teach me!",
          "next": "firstFunction"
        }
      ]
    },
    "firstFunction": {
      "id": "firstFunction",
      "speaker": "Pixel",
      "text": "Functions are defined with 'def' and called by name. Like creating a spell, then casting it!",
      "codeExample": "# Define the function (create the spell)\ndef attack():\n    print('Swinging sword!')\n    print('Enemy takes 10 damage!')\n\n# Call the function (cast the spell)\nattack()\nattack()  # Can use it multiple times!",
      "followUp": "See? Define once with 'def', then call it whenever you need!",
      "options": [
        {
          "text": "Can functions take inputs?",
          "next": "parameters"
        },
        {
          "text": "What about returning values?",
          "next": "returnValues"
        }
      ]
    },
    "parameters": {
      "id": "parameters",
      "speaker": "Pixel",
      "text": "Yes! Parameters let functions accept inputs - like damage amounts or enemy names!",
      "codeExample": "# Function with parameters\ndef attack(enemy_name, damage):\n    print(f'Attacking {enemy_name}!')\n    print(f'{enemy_name} takes {damage} damage!')\n\n# Call with different values\nattack('Goblin', 25)\nattack('Dragon', 50)\nattack('Slime', 10)",
      "followUp": "Parameters make functions flexible - one function, infinite possibilities!",
      "options": [
        {
          "text": "Can I have optional parameters?",
          "next": "defaultParams"
        },
        {
          "text": "How do I return values?",
          "next": "returnValues"
        }
      ]
    },
    "defaultParams": {
      "id": "defaultParams",
      "speaker": "Pixel",
      "text": "Default parameters give fallback values - perfect for optional settings!",
      "codeExample": "# Default parameters\ndef heal(amount=50, show_effect=True):\n    print(f'Healing {amount} HP!')\n    if show_effect:\n        print('âœ¨ Sparkles appear! âœ¨')\n\n# Different ways to call\nheal()           # Uses defaults: 50, True\nheal(30)         # Custom amount: 30, True\nheal(100, False) # Full custom: 100, False\nheal(show_effect=False)  # Named parameter!",
      "followUp": "Defaults make functions user-friendly - they work even if you forget parameters!",
      "options": [
        {
          "text": "Show me return values!",
          "next": "returnValues"
        }
      ]
    },
    "returnValues": {
      "id": "returnValues",
      "speaker": "Pixel",
      "text": "Functions can return values - like asking 'how much damage?' and getting an answer!",
      "codeExample": "# Function that returns a value\ndef calculate_damage(base, multiplier):\n    total = base * multiplier\n    return total\n\n# Use the returned value\ndamage = calculate_damage(10, 3)\nprint(f'Total damage: {damage}')  # 30\n\n# Return multiple values!\ndef get_stats():\n    return 100, 50, 25  # health, mana, armor\n\nhp, mp, armor = get_stats()\nprint(f'HP: {hp}, MP: {mp}, Armor: {armor}')",
      "followUp": "Return sends values back to whoever called the function!",
      "options": [
        {
          "text": "Can functions call other functions?",
          "next": "functionCalls"
        },
        {
          "text": "Show me a complete example!",
          "next": "completeExample"
        }
      ]
    },
    "functionCalls": {
      "id": "functionCalls",
      "speaker": "Pixel",
      "text": "Functions can call other functions - like combo attacks in fighting games!",
      "codeExample": "def roll_dice():\n    import random\n    return random.randint(1, 6)\n\ndef attack_with_critical():\n    base_damage = 10\n    dice_roll = roll_dice()  # Call another function!\n    \n    if dice_roll == 6:\n        print('CRITICAL HIT!')\n        return base_damage * 3\n    else:\n        return base_damage\n\n# Use it\ndamage = attack_with_critical()\nprint(f'Dealt {damage} damage!')",
      "followUp": "Functions calling functions - that's how complex games are built!",
      "options": [
        {
          "text": "What about variable scope?",
          "next": "scope"
        },
        {
          "text": "Show me more examples!",
          "next": "completeExample"
        }
      ]
    },
    "scope": {
      "id": "scope",
      "speaker": "Pixel",
      "text": "Variables inside functions are 'local' - they only exist in that function's bubble!",
      "codeExample": "player_gold = 100  # Global variable\n\ndef buy_item(cost):\n    # Local variable - only exists here\n    tax = cost * 0.1\n    total = cost + tax\n    \n    global player_gold  # Access global variable\n    if player_gold >= total:\n        player_gold -= total\n        return True\n    return False\n\n# Use it\nif buy_item(50):\n    print(f'Purchase complete! Gold left: {player_gold}')\nelse:\n    print('Not enough gold!')",
      "followUp": "Local variables = function's private stuff. Global = shared with everyone!",
      "options": [
        {
          "text": "Show me a game system example!",
          "next": "completeExample"
        }
      ]
    },
    "completeExample": {
      "id": "completeExample",
      "speaker": "Pixel",
      "text": "Let's build a complete combat system with functions!",
      "codeExample": "# Combat System\nimport random\n\ndef create_character(name, hp, attack):\n    return {'name': name, 'hp': hp, 'attack': attack}\n\ndef attack_enemy(attacker, defender):\n    damage = random.randint(1, attacker['attack'])\n    defender['hp'] -= damage\n    print(f\"{attacker['name']} deals {damage} damage!\")\n    return damage\n\ndef is_alive(character):\n    return character['hp'] > 0\n\ndef battle(player, enemy):\n    print(f\"Battle: {player['name']} vs {enemy['name']}!\")\n    \n    while is_alive(player) and is_alive(enemy):\n        attack_enemy(player, enemy)\n        if is_alive(enemy):\n            attack_enemy(enemy, player)\n        print(f\"HP - {player['name']}: {player['hp']}, {enemy['name']}: {enemy['hp']}\")\n    \n    winner = player if is_alive(player) else enemy\n    print(f\"{winner['name']} wins!\")\n\n# Use the system\nhero = create_character('Hero', 100, 20)\ngoblin = create_character('Goblin', 50, 15)\nbattle(hero, goblin)",
      "followUp": "See how functions work together to create a complete system? That's modular programming!",
      "options": [
        {
          "text": "Functions are like LEGO blocks!",
          "next": "lambdaIntro"
        }
      ]
    },
    "lambdaIntro": {
      "id": "lambdaIntro",
      "speaker": "Pixel",
      "text": "Bonus power-up: Lambda functions! Mini-functions for quick operations!",
      "codeExample": "# Regular function\ndef double(x):\n    return x * 2\n\n# Lambda function - same thing!\ndouble = lambda x: x * 2\n\n# Great for sorting!\nenemies = [\n    {'name': 'Goblin', 'hp': 30},\n    {'name': 'Orc', 'hp': 50},\n    {'name': 'Slime', 'hp': 10}\n]\n\n# Sort by HP\nenemies.sort(key=lambda e: e['hp'])\nprint('Weakest to strongest:')\nfor enemy in enemies:\n    print(f\"{enemy['name']}: {enemy['hp']} HP\")",
      "followUp": "Lambdas are like instant spells - quick, one-line functions!",
      "options": [
        {
          "text": "Time for practice!",
          "next": "practiceChallenge"
        }
      ]
    },
    "practiceChallenge": {
      "id": "practiceChallenge",
      "speaker": "Pixel",
      "text": "Ultimate Challenge: Create a shop system with functions!",
      "followUp": "Make functions for: displaying items, buying, selling, and checking gold!",
      "codeExample": "# Shop System Challenge\nplayer_gold = 100\ninventory = []\n\ndef show_shop(items):\n    print('=== SHOP ===')\n    for i, item in enumerate(items, 1):\n        print(f\"{i}. {item['name']} - {item['price']}g\")\n\ndef buy_item(item, gold):\n    if gold >= item['price']:\n        inventory.append(item['name'])\n        return gold - item['price']\n    else:\n        print('Not enough gold!')\n        return gold\n\ndef sell_item(item_name, sell_price):\n    global player_gold\n    if item_name in inventory:\n        inventory.remove(item_name)\n        player_gold += sell_price\n        print(f'Sold {item_name} for {sell_price}g!')\n    else:\n        print(\"You don't have that item!\")\n\n# Test the shop!\nshop_items = [\n    {'name': 'Sword', 'price': 50},\n    {'name': 'Potion', 'price': 20}\n]\n\nshow_shop(shop_items)\nplayer_gold = buy_item(shop_items[1], player_gold)\nprint(f'Gold: {player_gold}, Inventory: {inventory}')",
      "options": [
        {
          "text": "Functions make everything easier!",
          "next": "lessonComplete"
        }
      ]
    },
    "lessonComplete": {
      "id": "lessonComplete",
      "speaker": "Pixel",
      "text": "ðŸŽŠ LEVEL 6 COMPLETE! You can now create your own commands! âš¡",
      "followUp": "Functions are the building blocks of every game - now you can build anything!",
      "action": "completeLesson",
      "actionParams": { "lesson": 6, "nextLesson": 7 },
      "options": [
        {
          "text": "On to Lesson 7 - Dictionaries!",
          "action": "loadLesson",
          "actionParams": { "lesson": 7 }
        },
        {
          "text": "I want to build games now!",
          "action": "startGameMode"
        },
        {
          "text": "Back to lesson menu",
          "action": "openLessons"
        }
      ]
    }
  },
  "startNode": "start"
}